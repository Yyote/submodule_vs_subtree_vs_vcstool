# README 

Этот репозиторий иллюстрирует применение различных подходов к отслеживанию историй составных репозиториев.

## subtree 

Текущий подход иллюстрирует слияние историй репозиториев так, будто бы они всегда развивались, как один репозиторий. Этот подход часто описывается, как наиболее простой из всех, однако эта фраза работает при выполнении некоторых условий по использованию проекта поддерева.

### Плюсы подхода subtree

#### Высокая простота повседневного использования dependency 

Это означает, что клонировать, версионировать, ссылаться и использовать код из репозитория dependency дествительно просто.

Чтобы склонировать репозиторий с поддеревом, нужно просто склонировать родительский репозиторий:

```bash
git clone https://github.com/Yyote/submodule_vs_subtree_vs_vcstool.git # Представим, что subtree это master
```

После этого весь код репозитория dependency находится в ./src/dependency/ и работать с ним можно, как с любым другим.

**Суть слияния историй и всего подхода subtree в целом**, что дальнейшие действия с историей репозитория и подрепозитория воспринимаются, как одно целое ровно до тех пор, пока разработчик спецаильно не решит обратиться конкретно к истории подрепозитория.

git subtree pull/push как и add будут обращать внимание на --prefix и отделять/смешивать истории двух репозиториев, что позволит вносить доработки в подрепозиторий из основного проекта.

Расхождение историй в случае subtree pull не приведет к проблемам и будет восприниматься локальным репозиторием, как обычный merge.

Расхождение историй в случае subtree push не приведет к проблемам и покажет классческую ошибку-отказ.

Также вы можете прямо из основного репозитория запушить поддерево в новую ветку в git subtree push указав еще не существующую. 

### Минусы

#### 1. Неопределенность в соотношении локальной версии поддерева и удаленной

Вы не можете просто взять и проверить версию ветки dependency. Единственная зацепка, которую вы можете получить - номер коммита из git log.

#### 2. Высокий вес файлов истории

Так как истории основного и включенного репозитория буквально объеденены, blob-объекты будут отслеживать оба репозитория и весить соответственно. По этому пункту данный метод проигрывает всем остальным.

### Общее впечатление 

В целом это довольно простой способ отслеживания составных проектов, который позволяет взаимодействовать и с основным репозиторием, и с подрепозиторием одновременно.
